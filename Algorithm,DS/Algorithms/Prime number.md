# 소수 판별 알고리즘

[BOJ 2986](https://github.com/baeharam/PS/blob/master/Prime%20Number/2986%EB%B2%88(%ED%8C%8C%EC%8A%A4%EC%B9%BC).cpp) 을 풀다가 소수를 판별할 때 알고리즘을 정리해야 될 것 같아서 작성한다. 아주 당연한 방법으로는 브루트 포스로 2부터 N-1까지 반복문을 돌면서 나눠지는지 판별하는 것이다. 

```c++
for(int i=2; i<=n-1; i++){
    if(n%i==0) break;
}
```

그러나 당연히 거의 모든 문제에서 TLE가 발생하기 때문에 시간을 최대한 줄여야 한다. 잘 생각해보면 굳이 N-1까지 할 필요가 없는 것이 N을 나눌 수 있는 숫자는 N 자체를 제외하곤 N/2라는 것은 자명한 사실이다. 약수에 곱할 수 있는 가장 작은 숫자가 2이기 때문이다. 따라서 다음과 같이 개선할 수 있다.

```c++
for(int i=2; i<=n/2; i++){
    if(n%i==0) break;
}
```

하지만 이것도 반 이상의 문제에서 TLE가 발생하므로 더 개선해야 한다. 이 때 제곱근을 이용할 수 있으며 시간을 효과적으로 줄일 수 있다. 제곱근까지만 검사해보면 1과 자신외의 약수가 존재하는지 판별할 수 있다. 왜 그것이 가능할까? N을 소수가 아니라고 하면 $N=a*b$로 나타낼 수 있는데 a와 b중 작거나 같은 값은 최대로 $\sqrt N$을 가질수 밖에 없고, 그 말은 약수의 최댓값이 $\sqrt N$이라는 말과 동일하다. 따라서 $\sqrt N$ 까지만 검사해보면 더 빠르게 소수를 판별할 수 있다.

```c++
for(int i=2; i*i<=n; i++){
    if(n%i==0) break;
}
```

이런식으로 말고도 \<cmath>의 sqrt 함수를 사용해도 된다. 이제 제일 빠른 방법을 알았으니 소수를 판별하거나 에라토스테네스의 체를 이용해서 일정범위의 소수를 구할 때는 3번째를 사용하도록 하자.