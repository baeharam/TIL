# Rabin-Karp algorithm(라빈-카프 알고리즘)

라빈-카프 알고리즘은 문자열 매칭에 쓰이는 알고리즘으로 주어진 문자열에서 어떤 패턴이 발생하는가를 확인하는 알고리즘이다. 기존의 문자열 매칭은 $NAVIE-STRING-MATCHER$ 알고리즘을 사용했는데 단순 브루트 포스로 모든 범위의 문자열에 대해 패턴 매칭을 시켜보는 방법이다.

문자열의 길이를 $n$, 패턴의 길이를 $m$이라고 했을 때, 두 방법 모두 $O((n-m+1)m)$으로 같지만 라빈-카프 알고리즘은 기존 알고리즘에 비해 preprocessing 과정을 거친다는 점이 다르고 평균적으로 더 빠르다.

## 아이디어

알고리즘의 핵심적인 아이디어는 $m$개의 문자를 $m$개의 숫자로 취급한다는 것이다. (length $m$ string is regarded as $m$ digits radix-$d$ number) 따라서 패턴 $P$와 문자열 $T$는 다음과 같이 표기할 수 있다.

* $P[1...m]$ : 길이 $m$의 패턴을 숫자로 바꿔서 $p$로 표시한다.
* 부분문자열 $T[s+1...s+m]$ : shift $s$가 증가하면서 패턴의 길이 $m$만큼의 부분문자열을 숫자로 바꿔서 $t_s$로 표시한다.

예를 들어, 문자열 $T$를 2359023141526739921이라고 하고 패턴 $P$를 31415라고 하자. 둘 다 문자열이기 때문에 숫자로 바꿔주어야 한다. 여기서 기준은 10진수로 하겠지만 다른 진법을 이용할 수도 있다. 처음 패턴 $P$인 31415는 $Horner's \ rule$에 의해서  다음과 같이 계산된다.
$$
p=P[m]+10(P[m-1]+10(P[m-2]+...+10(P[2]+10(P[1])))) \\
p=5+10(1+10(4+10(1+10*3)))=31,425
$$
하지만 더하기와 곱하기 연산을 총 $m-1$번 수행해야하므로 문자열을 숫자로 바꿀 경우 $2(m-1)$의 연산이 발생한다. 패턴 $P$와 문자열 $T$에 대해서 전부 계산할 경우 $2(m-1)(n-m+2)$번의 연산이 발생하기 때문에 비효율적이라고 할 수 있다. 따라서 이걸 조금 더 쉽게 계산하는 방법이 존재한다. 제일 먼저 패턴 $P$를 숫자로 바꾸고 문자열 $T$의 첫번째 부분문자열인 $t_0$을 숫자로 바꿔놓으면 나머지 $t_s$는 다음 수식을 통해 $t_0$를 통해 구할 수 있다.
$$
t_{s+1}=10(t_s-10^{m-1}T[s])+T[s+m]
$$
어찌보면 당연한 것이, 문자열 $T$의 $t_0$는 23590인데 shift가 1이라고 했을 때 35902가 된다. 35902는 23590에서 20000을 빼고 문자열의 그 다음 인덱스 문자(숫자로바꿔서)를 더한것이라고 할 수 있다. 수식으로 쓴다면, $t_1=10(23590-10^4*2)+2=35902$ 가 된다. 연산횟수는 곱하기 2번, 더하기 1번, 빼기 1번으로 고정횟수이다. 따라서 기존의 연산횟수보다 훨신 개선되었다는 것을 알 수 있다. 

현재까지의 시간복잡도를 구해보면 처음 $p$와 $t_0$를 계산할 때 $\theta(m)$만큼 걸리고, 그 다음 $t_1...t_m$을 계산할 때 $\theta(n-m)$만큼 걸리는데 보통 $n \ge m$을 만족하기 때문에 $\theta(n-m)=\theta(n)$이라고 할 수 있다.



## 숫자가 너무 크다면?

위의 아이디어를 이용해서 문자열을 숫자로 바꿨는데 숫자가 너무 커서 한 워드에 들어갈수도 없는 크기가 된다면 비교하는데 constant time을 넘을 수 있다. 따라서 모듈러 연산을 사용해서 숫자의 크기를 대폭 줄여 비교하기로 한다. 어떤 숫자 2개의 모듈러를 한 나머지가 같을 경우 그 숫자는 같다고 확신할 수는 없지만 같을 가능성이 있다. 그러나, 만약 나머지가 다를 경우는 반드시 원래의 숫자는 다를 수밖에 없다. 왜냐하면 숫자가 같다면 나머지는 반드시 같기 때문이다. 이러한 경우를 다음의 용어로 나타낸다.

* Valid : $t_s \equiv p (mod\  q)\  and\  t_s=p$
* Spurious hit : $t_s \equiv p (mod\  q)\  and\  t_s\neq p$

$q$로 모듈러 한 $t_s$와 $p$가 같을 때, 원래의 숫자도 같으면 valid인 것이고, 아니면 spurious hit인 것이다. Spurious hit는 그냥 invalid라고 봐도 무방할 것 같다. 어쨌든 이 방식을 이용한다면 숫자의 크기가 아주 커질 경우에도 비교가능하게 된다.

숫자로 바꿀 때 적용한 진수를 $d$라고 하고 $d$에 대해서 계산한 자릿수의 최대크기를 $h$라고 하면 $t_{s+1}$의 모듈러는 다음과 같이 계산 가능하다.
$$
t_{s+1}=(d(t_s-T[s]*h)+T[s+m]) \ (mod\ q)
$$
수식만 보면 이해하기 힘드니 위에서 봤던 문자열의 두번째인 35902의 모듈러를 계산해보자. 먼저 $q$를 13이라고 하면 첫번째 부분문자열인 23590의 모듈러는 8이다.
$$
\begin{align}
35902 
&\equiv 10*(23590-2*10000)+2 \ (mod\ 13) \\
&\equiv 10*(8-2*3)+2 \ (mod\ 13) \\
&\equiv 9\ (mod\ 13)
\end{align}
$$
다음 식에서 미리 계산되어질 수 있는 값은 $h$와 $T[s], T[s+m]$인데 그 이유는 $h$의 경우 자릿수는 변하지 않기 때문이고 $T[s], T[s+m]$은 이미, $t_s$가 계산되어있기 때문이다. 따라서 이것들에 대해선 미리 모듈러를 해줄 수 있다. 참고로 [모듈러 연산은 분배법칙이 성립한다.](http://sexycoder.tistory.com/66?category=730623) 따라서 기존에 계산된 값들을 통해 더 빠르게 모듈러를 해줄 수 있게되는 것이다.

이렇게 각 숫자에 대해서 모듈러를 해주었으면 패턴의 모듈러와 비교를 하면서 문자열에서 패턴이 발생하는지 파악해야 하는데, 주의할 점은 모듈러가 같다고 숫자가 같은 것이 아니므로 valid인지 spurious hit인지 구분해서 shift 몇번째에서 패턴이 발생하는지 알아낼 수 있다.



## 시간 복잡도

총 시간복잡도는 어떻게 될까? 먼저, $p$와 $t_0$를 preprocessing 하는 시간이 $\theta(m)$ 만큼 걸린다. 또한 문자열을 숫자로 변환해서 모듈러 시키는 연산은 $\theta(n-m+1)$ 만큼 걸린다. 만약, 문자열의 모듈러와 패턴의 모듈러가 전부 같다면 worst case로 $n-m+1$번의 비교를 거쳐야 하므로 총 시간 복잡도는 $\theta((n-m+1)*m+m)$과 같기 때문에 $\theta((n-m+1)*m)$이다.