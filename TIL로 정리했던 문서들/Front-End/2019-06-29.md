## 가상 요소(Pseudo-Element)

[유튜브 강의](https://www.youtube.com/watch?v=wTUMrLAbREo)

특정 엘리먼트의 `:before` 나 `:after` 가 붙는 경우에 해당 엘리먼트의 "컨텐츠" 기준으로 뒤냐 앞이냐이다. 또한 HTML에는 없고 CSS의 꾸밈요소로서 의미를 갖기 때문에 DOM에 속하지 않고 JS로도 제어할 수 없으며 검색엔진이나 스크린 리더기에 적용되지 않는다. 역시 IE 6,7에서도 지원하지 않는다… 그리고 헷갈리게 생긴 `:hover` 는 가상클래스이다.

* CSS3 부터 `::` 로 표기하지만 하위 브라우저 호환 때문에 `:` 를 쓰는 것이 안정적이다.
* `attr` 을 이용해서 태그의 속성값을 가져올 수 있다.
* 공통적으로 들어가야하는 기호나 숫자를 마크업에 넣지 않고 균등하게 CSS로 처리할 수 있다.
* 가상요소는 인라인 요소이기 때문에 `display: block` 효과를 주기 위해선 `position: absolute` 로 처리할 수 있다.
* 이미지를 공통으로 추가할 때도 가상요소를 사용하는 경우가 많다.

## 네거티브 마진(Negative Margin)

[유튜브 강의](https://www.youtube.com/watch?v=OVaKTdFe5Bk)

* 아래에 있는 마크업이 위에 있는 것보다 앞쪽으로 나옴
  * `margin-left` 나 `margin-top` 에 주면 더 빨리 시작하게 하는 것
  * `margin-right` 나 `margin-bottom` 에 주면 더 빨리 끝나게 하는 것
* Block-level element인 경우 엘리먼트가 이동하지 않고 늘어남
* 기존 CSS 표준에 있는 것이기 때문에 호환성 문제 없음

## em과 rem

* **em**
  * 부모의 폰트 사이즈를 상속받아 정해진 비율을 곱해서 계산한다.
  * 부모에 따라 폰트와 같이 커지고 작아지는 경우는 em을 사용해야 한다.
* **rem**
  * 그러나 상속관계가 복잡해질 경우 em을 계산하기가 까다롭기 때문에 부모에 영향을 받지 않는 엘리먼트의 경우라면 rem으로 설정해줘야 한다.
  * 폰트 사이즈는 rem을 활용하는 것이 제일 적합하다.

## 선택자 우선순위

[유튜브 강의](https://www.youtube.com/watch?v=p6VxdiNTrGg)

* 동일한 우선순위일 경우 아래것으로 덮어씌워짐
* 구체적인 것이 우선수위가 더 높음, 예를 들어 `*` 보다 `h1` 이 우선순위 더 높음
* 태그이름보다 클래스 우선순위가 더 높음
* 아이디가 클래스보다 우선순위가 더 높음
* 아이디가 클래스+가상클래스보다 우선순위가 더 높음
* 인라인 속성의 우선순위가 가장 높음

## line-height

[유튜브 강의](https://www.youtube.com/watch?v=SDa7f8os2WA)

* `em` 단위를 쓰는 것과 그냥 숫자를 쓰는 것은 다르기 때문에 단위 없이 작성하는 것이 적합하다.
* `font-size` 를 지정해도 그것보다 커지는 이유는 leading 영역, 즉 가독성을 위한 공간이 추가되기 때문이다.
* 따라서 `line-height` 는 `font-size` 와 leading 영역을 합치는 것이다. 
* 기본값은 `normal` 인데 기본으로 leading 영역이 설정된 것이며 이걸 지우기 위해선 실제 값을 주면 된다. 또한 각 폰트 종류마다 폰트 디자이너가 설정한 값이 있으므로  `line-height` 가 다르다는 것을 명심하자.

## 자바스크립트 데이터 타입과 연산자

* 객체의 프로퍼티에 값을 할당할 때, 프로퍼티가 이미 있을 경우는 해당 프로퍼티의 값이 갱신되지만, 객체의 해당 프로퍼티가 없을 경우에는 새로운 프로퍼티가 **"동적으로**" 생성된 후 값이 할당된다.

* 객체의 프로퍼티를 읽을 때 대괄호 표기법 만을 사용해야 하는 경우

  * `full-name` 과 같이 표현식이거나 예약어인 경우에 해당된다. 그러나 테스트 해본 결과 예약어를 dot notation으로 사용해도 작동하는데 뭐가 문제인지는 나중에 찾아봐야 한다.

* `for in` 을 사용하여 객체의 프로퍼티를 순회할 수 있다.

* `delete` 를 사용하여 객체의 프로퍼티를 삭제할 수는 있지만 객체를 삭제할 수는 없다.

* JS에서 객체는 실제값이 아닌 생성된 객체를 가리키는 참조변수를 가리키므로 객체를 참조타입이라고 하는 것이다.

  * 동등 연산자(==)를 사용할 때도 객체의 프로퍼티 값들이 아닌 참조변수의 참조값을 비교한다.
  * call by value가 아닌 call by reference 이기 때문에 함수 내에서 객체의 프로퍼티 값을 변경하면 실제로 바뀐다.

* 모든 객체는 자신의 부모객체를 가지고 있으며 그것을 "프로토타입 객체"라고 한다.

  * ECMAScript 명세서에는 모든 객체가 `[[Prototype]]` 이라는 숨겨진 프로퍼티를 가지고 있으며 이는 크롬 브라우저에서 `__proto__` 로 표시된다.
  * `[[Prototype]]` 프로퍼티는 프로토타입 객체를 가리킨다.
  * 모든 객체는 생성될 때 프로토타입이 결정되며 객체 리터럴로 생성할 경우 `Object.prototype` 이 프로토타입 객체가 된다는 것을 기억하자.

* 배열의 크기는 배열 인덱스 중 가장 큰 값 기준으로 결정되며 인덱스에 해당하는 값이 결정되지 않았다면 `undefined` 이다.

* 배열의 `length` 기준으로 `push` 메서드가 적용되는데 `length` 가 6일 경우 해당 인덱스에 값이 들어가게 된다.

* 대괄호 표기법으로 객체의 프로퍼티에 접근할 때 숫자일 경우 자동으로 문자열로 바뀐다.

* 객체와 배열 모두 `typeof` 연산자를 사용해서 확인할 경우 `object` 이다.

* 배열에도 프로퍼티를 동적으로 추가할 수 있는데 이 때 `length` 의 값은 변하지 않으며 가장 큰 인덱스가 변했을 경우만 변한다.

* ```javascript
  var arr = [1,2,3];
  arr.name = 'haram';
  console.log(arr.length); // 3
  arr[3] = 4;
  console.log(arr.length); // 4
  ```

* 배열도 객체이기 때문에 `delete` 를 사용할 수 있으나 원소 자체가 삭제되는 것은 아니며 `undefined` 로 초기화하는 것이다.

* ```javascript
  var arr = [1,2,3];
  delete arr[2];
  console.log(arr.length) // 3
  ```

* 동등(==) 연산자는 타입변환을 하지만 일치(===) 연산자는 타입변환을 하지 않는다.

* `!!{}` 의 경우 빈 객체를 불리안 타입으로 변환하는 것인데 `true` 를 반환한다는 것을 기억하자.

## 함수

* 함수 표현식에 사용된 함수 이름은 외부에서 사용할 수 없다.

```javascript
var sum = function add(x,y){
    return x+y;
}
console.log(sum(1,2)); // 3
console.log(add(1,2)); // error!!
```

* 함수 선언문(function statement)에는 세미콜론을 쓰지 않지만 함수 표현식(function expression)에는 세미콜론을 사용하는 것이 좋다.
* 함수 호이스팅(function hoisting)으로 인해 함수 선언문이 사용되기 전에 선언되어야 한다는 규칙을 무시하므로 더글라스 크락포드는 **"함수 표현식"을 사용할 것을 권장한다.**
* 함수는 일급(first class) 객체로 다음 기능들이 모두 가능하다.
  * 리터럴에 의한 생성
  * 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
  * 함수의 인자로 전달 가능
  * 함수의 리턴값으로 리턴 가능
  * 동적으로 프로퍼티를 생성 및 할당 가능
* 모든 함수 객체는 `prototype` 프로퍼티를 가진다.
  * `prototype` 프로퍼티는 이 함수가 생성자 함수(constructor function)로 사용되어 생성된 객체의 프로토타입 객체를 가리킨다.
  * 또한 해당 프로토타입 객체의 `constructor` 는 이 함수를 가리킨다.
* 즉시실행함수표현(IIFE, Immediately Invoked Function Expression)은 함수를 만들고 최초 1번만 실행하는 것으로 jQuery와 같은 라이브러리나 다른 프레임워크에 많이 사용되는데, 그 이유는 js에서 유효범위가 함수 기준으로 설정되기 때문이다. 따라서 다른 라이브러리와의 이름충돌을 피하기 위해 전체코드를 IIFE로 감싸는 경우가 많다.
* 함수를 호출할 때 인자의 개수는 상관없으며 `arguments` 객체가 함수 내부로 전달된다. 이 때 `arguments` 객체는 유사 배열 객체로서 `length` 값을 가지며 인자의 개수를 말한다.