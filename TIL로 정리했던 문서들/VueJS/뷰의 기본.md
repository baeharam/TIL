* one-way binding: 리액트의 props와 같은 한쪽방향 바인딩
* 디렉티브 = 이러이러하게 작동해라! 라고 엘리먼트에게 지시하는 역할
  * `v-` 접두사를 지님
  * `v-text` : 텍스트 렌더링
  * `v-html` : html 렌더링, 서버측에서 불필요한 부분 필터링하게 할 것!
  * `v-show` : 보여질지 말지에 대한 불리언 값
  * `v-if` : 조건부 렌더링
  * `v-else` : `v-if` 와 짝지어지는 반대쪽 조건부 렌더링
  * `v-else-if` : 첫번째 조건이 참이 아닐 때 그 다음 조건을 주기 위함. 이 위의 것들은 연속적으로 있어야 함
  * `v-pre` : 특정 엘리먼트 무시, 지시문이 없다는 걸로 인식하여 자식 엘리먼트 건너뜀, 컴파일 속도 빨라짐
  * `v-cloak` : 뷰 인스턴스가 준비되기 전까지 html 숨겨줌
  * `v-once` : 초기에 딱 한번만 렌더링
  * `v-bind` : HTML의 속성값을 변수로 적용하기 위해 사용 `<img v-bind:src=".." />` 또는 `<img :src=".." />` 와 같이 사용
  * `v-for` : HTML을 for문 사용해서 렌더링 하기 위함 `v-for="(element, index) in elements"` 와 같이 사용
  * `v-model` : 폼에 관련된 태그에서 양방향 바인딩을 구현하기 위함, 예를 들어, 체크박스 체크/해제에 따라 데이터에 반영되고 그에 따라 뷰가 달라지는 모습
  * `v-on` : 이벤트 핸들러를 달기 위한 디렉티브, 뷰 인스턴스에 선언한 메소드를 사용해서 핸들링 가능, `v-on:` 이나 `@` 다음에 이벤트 이름 하고 메소드 이름
* computed
  * 특정 데이터가 종속된 함수로 복잡한 연산할 때 사용하며 그 데이터가 변할 때만 함수 실행, 캐싱해 놓는다.
* watch
  * 특정 데이터를 감시하고 있다가 변할 때마다 함수 실행, 사용자 입력의 디바운스가 예시가 될 수 있음
* 뷰 인스턴스와 데이터
  * 데이터가 변경되면 화면이 다시 렌더링 되는데, 이 때의 데이터는 **뷰 인스턴스가 생성될 때의 데이터!**
  * 단, `Object.freeze` 로 객체를 immutable 하게 만들면 화면이 렌더링 되지 않음
* 일반 데이터 속성은 `vm.a` 와 같이 하고 뷰 인스턴스의 속성으 `vm.$watch` 와 같이 `$` 를 붙여서 표현
* 뷰 컴포넌트
  * 뷰 인스턴스의 캡슐화 버전, `is` 속성으로 원시 HTML 엘리먼트로도 표현 가능
  * data는 반드시 함수여야 하며 각 컴포넌트가 각자의 상태를 가지기 위해선 새로운 객체를 리턴해야 함
  * props는 부모에서 자식으로, events는 자식에서 부모로 전달
* `:class` 와 `:style` 은 객체로 지정 가능
* `$root` 와 `$parent` 를 통해서 루트 컴포넌트와 부모 컴포넌트에 접근 가능
* 배열 및 객체는 인덱스나 프로퍼티를 바꾸면 바뀌지 않는다. (참조타입의 값)
  * Vue.set 또는 `this.$set` 으로 바꿀 수 있음
* EventBus는 중앙에서 이벤트를 통제, VueX는 데이터를 중앙에서 통제
* Vuex
  * state: 상태관리
  * getters: computed 같은 것
  * mutations: 동기적 상태 업데이트
  * actions: 비동기적 업데이트나 여러개의 mutation
* Vuex의 state는 computed로 연결 ---> `mapState()` 로 한방에 처리
* `this.$store.commit(mutation 이름)` 으로 상태 업데이트
* slot: 태그를 넘겨서 렌더링할 수 있음

